

/*

Алгоритм обходу дерева - це метод проходження крізь всі вузли дерева в певному порядку. Дерево є структурою даних, що складається з вузлів, які можуть мати підвузли. Кожен вузол може мати декілька нащадків, які називаються дітьми.

Існує кілька типів алгоритмів обходу дерева:

Прямий обхід (Pre-order traversal): спочатку відвідуються кореневий вузол, потім його ліве і праве піддерева.

Центральний обхід (In-order traversal): спочатку відвідуються всі вузли лівого піддерева, потім кореневий вузол, а потім всі вузли правого піддерева.

Зворотний обхід (Post-order traversal): спочатку відвідуються всі вузли лівого піддерева, потім всі вузли правого піддерева, а потім кореневий вузол.

Обхід в ширину (Breadth-first traversal): відвідуються всі вузли на кожному рівні дерева починаючи з кореневого вузла і продовжуючи зліва направо.

Ці алгоритми допомагають відшукати всі вузли у дереві, що дозволяє виконувати різноманітні дії на кожному вузлі. Наприклад, можна роздрукувати значення вузлів у правильному порядку, порахувати кількість вузлів у дереві або знайти максимальне значення вузлів.


*/




const tree = [
	{
		v: 5,
		c: [
			{
				v: 10,
				c: [
					{
						v: 11,
					},
				],
			},
			{
				v: 7,
				c: [
					{
						v: 5,
						c: [
							{
								v: 1,
							},
						],
					},
				],
			},
		],
	},
	{
		v: 5,
		c: [
			{
				v: 10,
			},
			{
				v: 15,
			},
		],
	},
];

const recursive = (tree) => {
	let sum = 0;
	tree.forEach((node) => {
		sum += node.v;
		if (!node.c) {
			return node.v;
		}
		sum += recursive(node.c);
	});
	return sum;
};

const iteration = (tree) => {
	if (!tree.length) {
		return 0;
	}
	let sum = 0;
	let stack = [];
	tree.forEach((node) => stack.push(node));
	while (stack.length) {
		const node = stack.pop();
		sum += node.v;
		if (node.c) {
			node.c.forEach((child) => stack.push(child));
		}
	}
	return sum;
};

console.log(iteration(tree));
// console.log(recursive(tree))


/*

Цей код містить дві функції recursive та iteration, які обчислюють суму всіх значень вузлів дерева.

Перша функція recursive є рекурсивною та обходить дерево, починаючи з кореневого вузла та рекурсивно обходячи піддерева. Кожен вузол додається до змінної sum. Якщо поточний вузол має підвузли, то рекурсивно викликається функція recursive для кожного з них, щоб знайти їх значення. Якщо поточний вузол не має підвузлів, то повертається його значення. В кінці повертається сума всіх значень вузлів.

Друга функція iteration використовує ітераційний підхід для обходу дерева за допомогою стеку. Кореневий вузол додається до стеку. Доки стек не порожній, вузол видаляється з вершини стеку і його значення додається до змінної sum. Якщо поточний вузол має підвузли, то кожен з них додається до стеку. Після того, як всі вузли були оброблені, повертається сума всіх значень вузлів.

Обидві функції дозволяють обчислити суму всіх значень вузлів дерева, але recursive використовує рекурсію, що може призвести до переповнення стеку, якщо дерево дуже глибоке, тоді як iteration використовує стек для ітераційного обходу дерева, що може бути ефективнішим для більш глибоких дерев.

*/