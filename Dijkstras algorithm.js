/*

Алгоритм Дейкстри - це алгоритм пошуку найкоротшого шляху в графі з невід'ємними вагами ребер. Принцип роботи алгоритму полягає в тому, що він знаходить найкоротший шлях від одного вершини графу до всіх інших вершин, причому він розглядає всі можливі шляхи з поточної вершини і обирає шлях з найменшою вагою.

Алгоритм Дейкстри працює наступним чином:

Візьміть початкову вершину і встановіть для неї відстань рівну нулю. Для всіх інших вершин встановіть відстань рівною нескінченності.

Оберіть вершину з найменшою відстанню та розгляньте всі сусідні вершини. Якщо шлях через поточну вершину коротший, ніж будь-який раніше знайдений шлях, то оновіть відстань до цієї вершини.

Позначте поточну вершину як відвідану та перейдіть до наступної вершини з найменшою відстанню.

Повторюйте кроки 2 та 3, поки всі вершини не будуть відвідані.

Найкоротший шлях буде знайдений, коли всі вершини будуть відвідані, а відстань до кожної з них буде відомою.

Алгоритм Дейкстри є дуже ефективним для пошуку найкоротших шляхів в графах з невеликою кількістю вершин і ребер. Однак, для більш складних графів з багатою кількістю ребер, можуть бути використані більш продуктивні алгоритми, такі як Алгоритм Беллмана-Форда або Алгоритм А* з покращеними евристиками.

*/

const graph = {};
graph.a = { b: 2, c: 1 };
graph.b = { f: 7 };
graph.c = { d: 5, e: 2 };
graph.d = { f: 2 };
graph.e = { f: 1 };
graph.f = { g: 1 };
graph.g = {};

function shortPath(graf, start, end) {
	const costs = {};
	const processed = [];
	let neighbors = {};
	Object.keys(graph).forEach((node) => {
		if (node !== start) {
			let value = graph[start][node];
			costs[node] = value || 1000000000;
		}
	});
	let node = findNodeLowesCost(costs, processed);
	while (node) {
		const cost = costs[node];
		neighbors = graph[node];
		Object.keys(neighbors).forEach((neighbor) => {
			let newCost = cost + neighbors[neighbor];
			if (newCost < costs[neighbor]) {
				costs[neighbor] = newCost;
			}
		});
		processed.push(node);
		node = findNodeLowesCost(costs, processed);
	}
	return costs
}


function findNodeLowesCost(costs, processed) {
	let lowestCost = 1000000000;
	let lowestNode;
	Object.keys(costs).forEach(node => {
		let cost = costs[node];
		if (cost < lowestCost && !processed.includes(node)) {
			lowestCost = cost;
			lowestNode = node;
		}
	});
	return lowestNode;
}

console.log(shortPath(graph, 'a', 'g'));

/*

Цей код реалізує алгоритм пошуку найкоротшого шляху в графі, використовуючи алгоритм Дейкстри.

Спочатку ми визначаємо граф за допомогою об'єкта graph. Граф складається з вершин та ребер. У цьому випадку граф містить вершини з a до g, а ребра зберігаються як вкладені об'єкти в межах кожної вершини.

Функція shortPath приймає три аргументи: graf - граф, у якому ми шукаємо найкоротший шлях, start - початкова вершина і end - кінцева вершина.

Функція спочатку створює порожні об'єкти costs та processed. costs зберігає вартість найкоротшого шляху до кожної вершини, а processed зберігає відвідані вершини.

Наступним кроком є визначення вартості найкоротшого шляху до кожної вершини. Для цього ми проходимося по всіх вершинах графу за допомогою Object.keys(graph).forEach((node) => {...}). Якщо ми не знаходимося в початковій вершині, ми встановлюємо вартість найкоротшого шляху до цієї вершини рівною значенню ребра, яке з'єднує початкову вершину з цією вершиною. Якщо таке ребро відсутнє, вартість ставиться на дуже велике число, що означає, що ми не можемо дістатися до цієї вершини.

Після визначення вартості найкоротшого шляху до кожної вершини, ми визначаємо вершину з найменшою вартістю за допомогою функції findNodeLowestCost. Ця функція повертає вершину з найменшою вартістю, яка ще не була відвідана.
Далі виконується цикл while, доки змінна node містить значення. В середині циклу ми знаходимо вузол з найменшою вагою - це робиться за допомогою функції findNodeLowestCost, яка приймає на вхід об'єкт з вагами вузлів та масив відвіданих вузлів, і повертає вузол з найменшою вагою серед тих, які не були відвідані.

Після знаходження вузла з найменшою вагою ми проходимося по всіх його сусідах і оновлюємо їх ваги, якщо знайшли шлях з меншою вагою. Потім додаємо вузол з найменшою вагою до масиву відвіданих вузлів та повторюємо цикл, знаходячи вузол з наступною найменшою вагою серед тих, які залишилися невідвіданими.

Коли всі вузли відвідані, функція повертає об'єкт costs з вагами вузлів. Він містить ваги для всіх вузлів графа від початкового вузла до кожного вузла, якщо шлях існує. Якщо вага для певного вузла не змінилася, це означає, що шлях до цього вузла не існує. У нашому прикладі, в результаті виконання функції shortPath, ми отримали об'єкт з вагами вузлів для всіх можливих шляхів від вузла 'a' до вузла 'g' в графі.

*/
