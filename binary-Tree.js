
/*

Бінарне дерево є структурою даних, що складається з вузлів, пов'язаних між собою за допомогою ребер. Кожен вузол може мати не більше ніж два нащадки, які називаються "лівим" та "правим" нащадками.

Принцип роботи з бінарним деревом полягає в тому, щоб додавати, видаляти або знаходити вузли в цій структурі даних. Для того, щоб зберігати дані в бінарному дереві, потрібно знати які кроки потрібно зробити, щоб додати вузол до дерева.

При додаванні нового вузла в бінарне дерево, спочатку порівнюється значення нового вузла зі значенням кореня дерева. Якщо значення нового вузла менше, ніж значення кореня, то новий вузол додається до лівого нащадка кореня. Якщо значення нового вузла більше, ніж значення кореня, то новий вузол додається до правого нащадка кореня. Якщо значення нового вузла співпадає зі значенням кореня, то вузол не додається до дерева, оскільки такий вузол вже існує.

При пошуку вузла в бінарному дереві, спочатку порівнюється значення шуканого вузла зі значенням кореня. Якщо значення шуканого вузла менше, ніж значення кореня, то пошук продовжується в лівому нащадку кореня. Якщо значення шуканого вузла більше, ніж значення кореня, то пошук продовжується в правому нащадку кореня. Якщо значення шуканого вузла співпадає зі значенням кореня, то вузол знайдено. Якщо вузол не знайдено, то це означає, що він не зберігається в дереві.

При видаленні вузла з бінарного дерева, потрібно розглянути три можливі випадки:

1. Вузол, який потрібно видалити, не має нащадків. В такому випадку вузол просто видаляється з дерева.

2. Вузол, який потрібно видалити, має одного нащадка. В такому випадку цей нащадок стає прямим нащадком батьківського вузла, а вузол, який потрібно видалити, видаляється з дерева.

3. Вузол, який потрібно видалити, має двох нащадків. В такому випадку потрібно знайти найбільший вузол у лівому піддереві вузла, який потрібно видалити, і перемістити його в місце вузла, який потрібно видалити. Найбільший вузол у лівому піддереві не має правого нащадка, тому його можна перемістити без порушення порядку дерева. Після переміщення найбільшого вузла у лівому піддереві, вузол, який потрібно видалити, видаляється з дерева.

Бінарні дерева часто використовуються для зберігання та організації даних, таких як числа, рядки або об'єкти. Вони можуть бути використані для швидкого пошуку, вставки та видалення даних. Також вони є основою для більш складних структур даних, таких як бінарні пошукові дерева, червоно-чорні дерева та інші.

*/


class BinaryTree {
	constructor() {
		this.root = null;
	}

	add(value) {
		if (!this.root) {
			this.root = new TreeNode(value);
		} else {
			let node = this.root;
			let newNode = new TreeNode(value);
			while (node) {
				if (value > node.value) {
					if (!node.right) {
						break;
					}
					node = node.right;
				} else {
					if (!node.left) {
						break;
					}
					node = node.left;
				}
			}
			if (value > node.value) {
				node.right = newNode;
			} else {
				node.left = newNode;
			}
		}
	}

	print(root = this.root) {
		if (!root) {
			return true;
		}
		console.log(root.value);
		this.print(root.left);
		this.print(root.right);
	}
}

class TreeNode {
	constructor(value) {
		this.value = value;
		this.left = null;
		this.right = null;
	}
}

const tree = new BinaryTree();
tree.add(5);
tree.add(2);
tree.add(6);
tree.add(2);
tree.add(1);
tree.print();

/*

+++++++++++++++++++++++++++++++++++++++++++++
Опис коду:
Цей код визначає клас BinaryTree та клас TreeNode, та використовує їх для створення бінарного дерева та виведення його значень у порядку передпорядкування.

Клас BinaryTree має конструктор, який встановлює властивість root на null. Він також має метод add, який приймає параметр value та додає новий TreeNode з цим значенням до дерева. Якщо дерево порожнє (тобто this.root дорівнює null), метод add встановлює корінь на новий TreeNode. В іншому випадку він проходить по дереву, починаючи з кореня, порівнюючи значення, що має бути додано, зі значенням кожного вузла та рухаючись вліво чи вправо в залежності від того, чи менше чи більше значення вузла. Коли він досягає вузла, у якого немає дочірнього відповідного напрямку, він додає туди новий TreeNode.

Клас BinaryTree також має метод print, який приймає параметр root (за замовчуванням this.root) та виводить значення дерева в порядку передпорядкування (тобто корінь, ліве піддерево, праве піддерево). Він використовує рекурсію для проходження по дереву, спочатку виводячи значення поточного вузла, потім рекурсивно викликаючи себе з лівим дитинним вузлом, а потім з правим.

Клас TreeNode має конструктор, який встановлює властивості value, left та right на основі переданих параметрів.

Далі код створює новий екземпляр класу BinaryTree з назвою tree та додає кілька значень до нього за допомогою методу add. Нарешті, він викликає метод print на екземплярі tree, щоб вивести значення в порядку передпорядкування. Результат виконання має бути:

5
2
1
6

Це тому, що ми додали значення 5, 2, 6, 2 і 1 до бінарного дерева. Однак, коли ми додали другий 2, він був доданий як лівий дочірній елемент перших 2, оскільки він був меншим за його значення.

Метод друку проходить дерево в попередньому порядку, починаючи з кореня (це 5). Він друкує значення кореня (5), потім рекурсивно викликає себе з лівим дочірнім елементом (який дорівнює 2). Він друкує значення лівого дочірнього елемента (2), а потім рекурсивно викликає себе за допомогою лівого дочірнього елемента лівого дочірнього елемента (який дорівнює 1). Він друкує значення лівого дочірнього елемента лівого дочірнього елемента (1), потім повертається до батьківського дочірнього елемента лівого дочірнього елемента (який дорівнює 2) і рекурсивно викликає себе за допомогою правого дочірнього елемента лівого дочірнього елемента (який у цьому випадку дорівнює нулю) . Потім він повертається до батьківського елемента кореня (який дорівнює нулю) і рекурсивно викликає сам себе за допомогою правильного дочірнього елемента (який дорівнює 6). Він друкує значення правого дочірнього елемента (6), потім рекурсивно викликає себе з лівим дочірнім елементом правого дочірнього елемента (який є нульовим), а потім із правим дочірнім елементом правого дочірнього елемента (який дорівнює нулю). Оскільки більше немає вузлів для обходу, метод повертається.


*/