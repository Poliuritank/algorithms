/*

Бінарний пошук (також відомий як дихотомічний пошук) - це ефективний алгоритм пошуку елементу у відсортованому списку. Цей алгоритм використовує властивість відсортованого списку, що дозволяє ефективно зменшувати кількість можливих варіантів для пошуку шляхом поділу діапазону пошуку на дві частини і зосередження пошуку в тій частині, де може знаходитись потрібний елемент.

Алгоритм бінарного пошуку виконується наступним чином:

1. Обчислити середину діапазону пошуку.
2. Порівняти шуканий елемент з елементом, що знаходиться в середині діапазону пошуку.
3. Якщо елементи рівні, пошук завершено.
4. Якщо шуканий елемент менший за елемент в середині діапазону, пошук продовжується у лівій половині діапазону.
5. Якщо шуканий елемент більший за елемент в середині діапазону, пошук продовжується у правій половині діапазону.
6. Повторювати кроки 1-5 для скороченого діапазону пошуку, доки шуканий елемент не буде знайдений або не буде встановлено, що його відсутність в списку.

Алгоритм бінарного пошуку має часову складність O(log n), де n - кількість елементів у відсортованому списку. Це робить його дуже ефективним для пошуку у великих відсортованих списках.

*/

const arrB = [
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
];
let count = 0;
// loop method
function binarySearch(arrB, item) {
	let start = 0;
	let end = arrB.length;
	let middle;
	let found = false;
	let position = -1;
	while (found === false && start <= end) {
		count += 1;
		middle = Math.floor((start + end) / 2);
		if (arrB[middle] === item) {
			found = true;
			position = middle;
			return position;
		}
		if (item < arrB[middle]) {
			end = middle - 1;
		} else {
			start = middle + 1;
		}
	}
	return position;
}

console.log(binarySearch(arrB, 20));
console.log('count = ', count);


// recursive method
function recursiveBinarySearch(array, item, start, end) {
	count = 0;
	let middle = Math.floor((start + end) / 2);
	count++;
	if (item === array[middle]) {
		return middle;
	}
	if (item < array[middle]) {
		return recursiveBinarySearch(array, item, start, middle - 1);
	} else {
		return recursiveBinarySearch(array, item, middle + 1, end);
	}
}

console.log(recursiveBinarySearch(arrB, 20, 0, arrB.length));
console.log('count = ', count);


/*
Пояснення коду

Спочатку ми маємо відсортований масив arrB з довжиною 20 елементів. Ми також маємо змінну count, яка буде використовуватися для підрахунку кількості порівнянь, які виконується в ході бінарного пошуку.

Перша функція binarySearch використовує цикл while для пошуку елемента item в масиві arrB. Змінні start та end визначають початковий та кінцевий індекси, відповідно. Змінна middle обчислюється як середнє значення між start та end. У циклі ми перевіряємо, чи дорівнює arrB[middle] шуканому елементу. Якщо так, ми змінюємо змінну found на true, зберігаємо індекс middle в змінну position та повертаємо його. Якщо шуканий елемент менше, ніж arrB[middle], ми змінюємо змінну end на middle - 1, інакше ми змінюємо змінну start на middle + 1. Цей процес повторюється до тих пір, поки found залишається false та start не стане більшим за end. Якщо елемент не знайдено, повертається значення -1.

Друга функція recursiveBinarySearch робить те ж саме, що і перша, але використовує рекурсивний підхід. Замість циклу while вона використовує рекурсію для зменшення діапазону пошуку та виклику функції з новими значеннями start та end. Функція отримує параметри array, item, start та end. Початкові значення start та end для першого виклику функції повинні бути 0 та довжина масиву arrB відповідно.

У функції recursiveBinarySearch змінна middle також обчислюється як середнє значення між start та end. Якщо item дорівнює array[middle], ми повертаємо middle. Якщо item менше, ніж array[middle], ми рекурсивно викликаємо функцію з параметрами array, item, start та middle - 1. Якщо item більше, ніж array[middle], ми рекурсивно викликаємо функцію з параметрами array, item, middle + 1 та end. Цей процес повторюється до тих пір, поки item не буде знайдено, і тоді функція поверне його індекс. Якщо елемент не знайдено, повертається значення -1.

Обидві функції змінюють змінну count під час виконання, щоб відстежувати кількість порівнянь, які виконуються в ході бінарного пошуку.

Отже, бінарний пошук швидко знаходить шуканий елемент в відсортованому масиві, оскільки кожен крок скорочує кількість елементів, які треба перевірити на половину. Обидві функції binarySearch та recursiveBinarySearch виконують одну й ту ж задачу, але за допомогою різних методів - циклу while та рекурсії відповідно.
Варто зазначити, що змінна count використовується як глобальна змінна в обох виконаннях, що може призводити до проблем, якщо функції викликаються кілька разів поспіль. Краще визначати count в межах області видимості кожної функції, щоб уникнути будь-яких непередбачуваних побічних ефектів.

*/